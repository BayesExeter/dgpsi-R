% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{pack}
\alias{pack}
\title{Pack GP and DGP emulators into a bundle}
\usage{
pack(...)
}
\arguments{
\item{...}{a sequence of emulators produced by \code{\link[=gp]{gp()}} or \code{\link[=dgp]{dgp()}}.}
}
\value{
An S3 class named \code{bundle} to be used by \code{\link[=design]{design()}} for sequential designs. It has:
\itemize{
\item \emph{N} slots, each of which contains a GP or DGP emulator, where \emph{N} is the number of emulators that are provided to the function.
\item a slot called \code{data} which is a list that contains two elements \code{X} and \code{Y}. \code{X} is the training input data that is common to all
emulators, and \code{Y} is a matrix with each column corresponding to the training output data of an emulator.
}
}
\description{
This function packs GP emulators and DGP emulators (without likelihood layers) into a \code{bundle} class for
sequential designs if each emulator emulates one output dimension of the underlying simulator.
}
\details{
See further examples and tutorials at \url{https://mingdeyu.github.io/dgpsi-R/}.
}
\examples{
\dontrun{

# load packages and the Python env
library(lhs)
library(dgpsi)
init_py()

# construct a function with antwo-dimensional output
f <- function(x) {
 y1 = sin(30*((2*x-1)/2-0.4)^5)*cos(20*((2*x-1)/2-0.4))
 y2 = 1/3*sin(2*(2*x - 1))+2/3*exp(-30*(2*(2*x-1))^2)+1/3
 return(c(y1,y2))
}

# generate the initial design
X <- maximinLHS(10,1)
Y <- t(apply(X, 1, f))

# generate the validation data
validate_x <- maximinLHS(30,1)
validate_y <- t(apply(validate_x, f, MARGIN = 1))

# training a 2-layered DGP emulator with respect to each output with the global connection off
m1 <- dgp(X, Y[,1], connect=F)
m2 <- dgp(X, Y[,2], connect=F)

# specify the range of the input dimension
lim <- c(0, 1)

# pack emulators to form an emulator bundle
m <- pack(m1, m2)

# 1st wave of the sequential design with 10 steps
m <- design(m, N=10, limits = lim, f = f, x_test = validate_x, y_test = validate_y)

# 2nd wave of the sequential design with 10 steps
m <- design(m, N=10, limits = lim, f = f, x_test = validate_x, y_test = validate_y)

# 3rd wave of the sequential design with 10 steps using the aggregation function that
# takes the average of the criterion values across the two outputs
g <- function(x){
  return(mean(x))
}
m <- design(m, N=10, limits = lim, f = f, x_test = validate_x, y_test = validate_y, aggregate = g)

# draw the design created by the sequential design
draw(m,'design')

# inspect the trace of RMSEs during the sequential design
draw(m,'rmse')
}
}
