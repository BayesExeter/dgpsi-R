#' @title Gaussian process emulator construction
#'
#' @description This function builds and trains a GP emulator.
#'
#' @param X a matrix where each row is an input data point and each column is an input dimension.
#' @param Y a matrix with only one column and each row being an input data point.
#' @param struc an object produced by [kernel()] that gives a user-defined GP specifications. When `struc = NULL`,
#'     the GP specifications are automatically generated using information provided in `name`, `lengthscale`,
#'     `nugget_est`, `nugget`, and `internal_input_idx`. Defaults to `NULL`.
#' @param name kernel function to be used. Either `"sexp"` for squared exponential kernel or
#'     `"matern2.5"` for Mat√©rn-2.5 kernel. Defaults to `"sexp"`. This argument is only used when `struc = NULL`.
#' @param lengthscale initial values of lengthscales in the kernel function. It can be a single numeric value or a vector:
#' * if it is a single numeric value, it is assumed that kernel functions across input dimensions share the same lengthscale;
#' * if it is a vector (which must have a length of `ncol(X)`), it is assumed that kernel functions across input dimensions have different lengthscales.
#'
#' Defaults to a vector of 0.2. This argument is only used when `struc = NULL`.
#' @param nugget_est a bool indicating if the nugget term is to be estimated:
#' 1. `FALSE`: the nugget term is fixed to $1e-6$ for deterministic emulation where the model interpolates the training data points.
#' 2. `TRUE`: the nugget term will be estimated for stochastic emulation where model outputs are assumed to follow a homogeneous Gaussian distribution.
#'
#' Defaults to `FALSE`. This argument is only used when `struc = NULL`.
#' @param nugget the initial nugget value. If `nugget_est = FALSE`, the assigned value is fixed during the training. Defaults to `1e-6`.
#' @param verb an integer indicating the level of information to be printed during the function execution:
#' * `2`: trace information on GP initialization and a summary table of the initialized GP model.
#' * `1`: all information as in `2` except for the summary table.
#' * `0`: no trace information and the summary table.
#'
#' When `verb = 2`, you will have a chance to check the specified GP model (especially when a customized `struc` is provided) and decide if you want to proceed to training. Defaults to `1`.
#' @param internal_input_idx the column indices of `X` that are generated by the linked emulators in the feeding layer.
#'     Set `internal_input_idx = NULL` if the model is not linked to an emulator or all columns in `X` are
#'     generated by the linked emulators in the feeding layer. Defaults to `NULL`. This argument is only used when `struc = NULL`.
#' @param linked_idx the indices of columns in the pooled output matrix (formed by column-combined outputs of all emulators
#'     in the feeding layer) that will feed into the GP emulator. The length of `linked_idx` shall equal to the length of `internal_input_idx`
#'     when `internal_input_idx` is not `NULL`. Set `linked_idx = NULL` if the model is not intended
#'     for linked emulations. If the GP emulator is in the first layer of a system, `linked_idx` gives the column indices of the
#'     global input (formed by column-combining all input matrices of emulators in the first layer) that the GP emulator will use.
#'     Defaults to `NULL`.
#'
#' @return An S3 class that can be used by
#' * [predict()] for GP predictions.
#' * [lgp()] to construct linked (D)GP emulators.
#' @details See examples in Articles at <https://mingdeyu.github.io/dgpsi-R/>.
#' @md
#' @export
gp <- function(X, Y, struc = NULL, name = 'sexp', lengthscale = rep(0.2, ncol(X)), nugget_est = FALSE, nugget = 1e-6, verb = 1, internal_input_idx = NULL, linked_idx = NULL) {
  if (!is.matrix(X)) stop("X must be a matrix", call. = FALSE)
  if (!is.matrix(Y)) stop("Y must be a matrix", call. = FALSE)
  if ( nrow(X)!=nrow(Y) ) stop("X and Y have different number of rows.", call. = FALSE)
  n_dim_X <- ncol(X)
  n_dim_Y <- ncol(Y)
  if ( n_dim_Y != 1 ) {
    stop('Y must be a matrix with only one column for a GP model.', call. = FALSE)
  }

  if( !is.null(linked_idx) ) {
    linked_idx <- reticulate::np_array(as.integer(linked_idx - 1))
  }

  if ( is.null(struc) ) {
    if ( verb == 2|verb == 1 ) message("Auto-generating a GP structure:", appendLF = FALSE)

    if ( length(lengthscale) != 1 & length(lengthscale) != n_dim_X) {
      stop("length(lengthscale) must be 1 or ncol(X).", call. = FALSE)
    }

    if( !is.null(internal_input_idx) ) {
      external_input_idx <- setdiff(1:n_dim_X, internal_input_idx)
      if ( length(external_input_idx) == 0) {
        internal_input_idx = NULL
        external_input_idx = NULL
      } else {
        internal_input_idx <- reticulate::np_array(as.integer(internal_input_idx - 1))
        external_input_idx <- reticulate::np_array(as.integer(external_input_idx - 1))
      }
    } else {
      external_input_idx = NULL
    }

    struc <- pkg.env$dgpsi$kernel(length = reticulate::np_array(lengthscale), name = name, scale_est = TRUE, nugget = nugget, nugget_est = nugget_est,
                                  input_dim = internal_input_idx, connect = external_input_idx)

    if ( verb == 2|verb == 1 ) {
      message(" done")
      Sys.sleep(0.5)
    }
  }

  if ( verb == 2|verb == 1 ) message("Initializing the GP model ...", appendLF = FALSE)

  obj <- pkg.env$dgpsi$gp(X, Y, struc)

  if ( verb == 2 ){
    Sys.sleep(0.5)
    message(" done")
    Sys.sleep(0.5)
    message("Summarizing the initialized GP model ...", appendLF = FALSE)
    pkg.env$dgpsi$summary(obj, 'pretty')
    Sys.sleep(0.5)
    message(" done")
    Sys.sleep(0.5)
    pkg.env$sys$stdout$flush()
    ans <- readline(prompt="Enter [Y] to continue or [N] to cancel the training: ")
    if ( ans == 'N'|ans == 'n'|ans == 'No'|ans == 'no' ){
      stop('Training is cancelled.', call. = FALSE)
    } else {
      message("Training the GP model ...", appendLF = FALSE)
    }
  } else if ( verb == 1 ){
    Sys.sleep(0.5)
    message(" done")
    Sys.sleep(0.5)
    message("Training the GP model ...", appendLF = FALSE)
  }

  obj$train()

  res <- list()
  res[['trained_obj']] <- obj
  res[['container_obj']] <- pkg.env$dgpsi$container(obj$export(), linked_idx)
  res[['emulator_obj']] <- obj

  class(res) <- "gp_model"

  if ( verb == 2|verb == 1 ) message(" done")

  return(res)
}
