% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/design.R
\name{design}
\alias{design}
\alias{design.gp}
\alias{design.dgp}
\alias{design.bundle}
\title{Sequential design of a (D)GP emulator or a bundle of (D)GP emulators}
\usage{
design(
  object,
  N,
  x_cand,
  y_cand,
  n_cand,
  limits,
  f,
  freq,
  x_test,
  y_test,
  method,
  nugget_s,
  verb,
  check_point,
  cores,
  ...
)

\method{design}{gp}(
  object,
  N,
  x_cand = NULL,
  y_cand = NULL,
  n_cand = 200,
  limits = NULL,
  f = NULL,
  freq = c(1, 1),
  x_test = NULL,
  y_test = NULL,
  method = "ALM",
  nugget_s = 1,
  verb = TRUE,
  check_point = NULL,
  cores = c(1, 1),
  ...
)

\method{design}{dgp}(
  object,
  N,
  x_cand = NULL,
  y_cand = NULL,
  n_cand = 200,
  limits = NULL,
  f = NULL,
  freq = c(1, 1),
  x_test = NULL,
  y_test = NULL,
  method = "ALM",
  nugget_s = 1,
  verb = TRUE,
  check_point = NULL,
  cores = c(1, 1),
  threading = FALSE,
  train_N = 100,
  aggregate = NULL,
  ...
)

\method{design}{bundle}(
  object,
  N,
  x_cand = NULL,
  y_cand = NULL,
  n_cand = 200,
  limits = NULL,
  f = NULL,
  freq = c(1, 1),
  x_test = NULL,
  y_test = NULL,
  method = "ALM",
  nugget_s = 1,
  verb = TRUE,
  check_point = NULL,
  cores = c(1, 1),
  threading = FALSE,
  train_N = 100,
  aggregate = NULL,
  ...
)
}
\arguments{
\item{object}{can be one of the following:
\itemize{
\item the S3 class \code{gp}.
\item the S3 class \code{dgp}.
\item the S3 class \code{bundle}.
}}

\item{N}{the number of steps for the sequential design, i.e., the number of design points to be added to the emulator \code{object}.}

\item{x_cand}{a matrix (with each row being a design point and column being an input dimension) that gives a candidate set
in which the next design point is determined. If \code{x_cand = NULL}, the candidate set will be generated using \code{n_cand} and
\code{limits}. Defaults to \code{NULL}.}

\item{y_cand}{a matrix (with each row being a simulator evaluation and column being an output dimension) that gives the realizations
from the simulator at input positions in \code{x_cand}. Defaults to \code{NULL}.}

\item{n_cand}{an integer that gives
\itemize{
\item the size of the candidate set in which the next design point is determined, if \code{x_cand = NULL};
\item the size of a sub-set to be sampled from the candidate set \code{x_cand} at each step of the sequential design to determine the next
design point, if \code{x_cand} is not \code{NULL}.
}

Defaults to \code{200}}

\item{limits}{a two-column matrix that gives the ranges of each input dimension, or a vector of length two if there is only one
input dimension. If a vector is provided, it will be converted to a two-column row matrix. The rows of the matrix correspond to input
dimensions, and its first and second columns correspond to the minimum and maximum values of the input dimensions. If
\code{limits = NULL}, the ranges of input dimensions will be determined from the training data contained in \code{object}. This argument
is used when \code{x_cand = NULL} and \code{y_cand = NULL}. Defaults to \code{NULL}.}

\item{f}{an R function that represents the simulator. See \emph{Note} section below for details on specifications of \code{f}.}

\item{freq}{a vector of two integers with the first element giving the frequency (in number of steps) to re-fit the
emulator, and the second element giving the frequency to implement the emulator validation (for RMSE). Defaults to \code{c(1, 1)}.}

\item{x_test}{a matrix (with each row being an input testing data point and each column being an input dimension) that gives the testing
input data to evaluate the emulator after each step of the sequential design. Set to \code{NULL} for the LOO-based emulator validation.
Defaults to \code{NULL}.}

\item{y_test}{the testing output data that correspond to \code{x_test} for the emulator validation after each step of the sequential design:
\itemize{
\item if \code{object} is an instance of the \code{gp} class, \code{y_test} is a matrix with only one column and each row being an testing output data point.
\item if \code{object} is an instance of the \code{dgp} class, \code{y_test} is a matrix with its rows being testing output data points and columns being
output dimensions.
}

Set to \code{NULL} for the LOO-based emulator validation. Defaults to \code{NULL}.}

\item{method}{the criterion used to locate the design points: ALM (\code{"ALM"}) or MICE (\code{"MICE"}). See references below.
Defaults to \code{"ALM"}.}

\item{nugget_s}{the value of the smoothing nugget term used when \code{method = "MICE"}. Defaults to \code{1.0}.}

\item{verb}{a bool indicating if the trace information will be printed during the sequential design.
Defaults to \code{TRUE}.}

\item{check_point}{a vector of integers that indicates at which steps the sequential design will pause and ask for the confirmation
from the user if the sequential design should continue or be terminated. Set to \code{NULL} to suspend the manual intervention. Defaults
to \code{NULL}.}

\item{cores}{a vector of two integers that gives the number of cores/workers to be used for criterion calculations and emulator
validations, respectively. If either element is set to \code{NULL}, the number of cores is set to \verb{(max physical cores available - 1)}.
Defaults to \code{c(1, 1)}.}

\item{...}{N/A.}

\item{threading}{a bool indicating whether to use the multi-threading to accelerate criterion calculations and emulator
validations if \code{object} is an instance of the \code{dgp} class. Turning this option on could improve the speed of validations when the DGP emulator
is built with a moderately large number of training data points and the Mat√©rn-2.5 kernel.}

\item{train_N}{an integer or a vector of integers that gives the number of training iterations to be used to re-fit the DGP emulator at each step
of the sequential design:
\itemize{
\item If \code{train_N} is an integer, then at each step the DGP emulator will re-fitted (based on the frequency of re-fit specified in \code{freq}) with \code{train_N} iterations.
\item If \code{train_N} is a vector, then its size must be \code{N} even the re-fit frequency specified in \code{freq} is not one.
}

Defaults to \code{100}.}

\item{aggregate}{an R function that aggregates the ALM or MICE criterion across different output dimensions of a DGP emulator, or across outputs of different
emulators contained in an emulator bundle. See \emph{Note} section below for details on specifications of \code{aggregate}.}
}
\value{
An updated \code{object} is returned with a slot called \code{design} that contains:
\itemize{
\item \emph{S} slots, named \verb{wave1, wave2,..., waveS}, that contain information of \emph{S} waves of sequential designs that have been applied to the emulator.
Each slot contains two elements:
\itemize{
\item \code{N}, an integer that gives the numbers of steps implemented in the corresponding wave;
\item \code{rmse}, a matrix that gives the RMSEs of emulators constructed during the corresponding wave;
\item \code{freq}, an integer that gives the frequency that the emulator validations are implemented during the corresponding wave.
\item \code{aggregation}, a bool that indicates if the aggregation is applied (i.e., if \code{aggregate} is supplied) to locate the design points for a DGP
emulator or a bundle of (D)GP emulators during the corresponding wave.
}
\item a slot called \code{type} that gives the type of validations, either LOO (\code{loo}) or OOS (\code{oos}) used to calculate the RMSEs of emulators constructed
in the sequential design. See \code{\link[=validate]{validate()}} for more information about LOO and OOS.
\item two slots called \code{x_test} and \code{y_test} that contain the data points for the OOS validation if the \code{type} slot is \code{oos}.
}

See \emph{Note} section below for further information.
}
\description{
This function implements the sequential design of a (D)GP emulator or a bundle of (D)GP emulators.
}
\details{
See further examples and tutorials at \url{https://mingdeyu.github.io/dgpsi-R/}.
}
\note{
\itemize{
\item The re-fitting and validation of an emulator are forced after the final step of a sequential design even \code{N} is not multiples of elements in \code{freq}.
\item Any \code{loo} or \code{oos} slot that already exists in \code{object} will be cleaned, and a new slot called \code{loo} or \code{oos} will be created in the returned object
depending on whether \code{x_test} and \code{y_test} are provided. The new slot gives the validation information of the emulator constructed in the final step of
the sequential design. See \code{\link[=validate]{validate()}} for more information about the slots \code{loo} and \code{oos}.
\item If \code{object} has previously been used by \code{\link[=design]{design()}} for sequential designs, the information of the current wave of the sequential design will replace
those of old waves and be contained in the returned object, unless the following conditions are met:
\itemize{
\item the validation type (LOO or OOS) of the current wave of the sequential design is the same as the validation types in previous waves, and
\item if the validation type is OOS, \code{x_test} and \code{y_test} in the current wave of the sequential design are identical to those in the previous waves.
}

When the above conditions are met, the information (\code{N} and \code{rmse}) of the current wave of the sequential design will be added to
the \code{design} slot of the returned object under the name \code{waveS}.
\item If \code{object} is an instance of the \code{gp} class, the matrix in the \code{rmse} slot is single-columned. If \code{object} is an instance of
the \code{dgp} class, the matrix in the \code{rmse} slot can have multiple columns that correspond to different output dimensions.
\item \code{aggregate} can be defined as an R function with either one or two arguments.
\itemize{
\item if \code{aggregate} has one argument, the argument should be a vector representing values of ALM or MICE criterion across
\itemize{
\item different output dimensions of a DGP emulator; or
\item outputs of different emulators contained an emulator bundle,
at a design point.
}
\item if \code{aggregate} has two arguments, the additional argument should also be a vector that contains parameters that are involved in the criterion
aggregation. The values of the aggregation parameters should be specified by setting them as the default values of the second argument of
\code{aggregate}.
}
\item \code{f} should be defined as a function with only one argument which is a vector giving values of different simulator input dimensions. \code{f}
can return a single or two outputs.
\itemize{
\item if \code{f} has one output, it should return a vector that gives values of different simulator output dimensions.
\item if \code{f} has two outputs, it should return a list with two slots:
\itemize{
\item the first slot is a vector that gives values of different simulator output dimensions.
\item the second slot is a vector that gives values of aggregation parameters that will be used to update the criterion aggregation via \code{aggregate}
after each step of the sequential design.
}

In the two-output case, \code{aggregate} must be provided and defined with two arguments.
}
\item When defining \code{f} and \code{aggregate}, it is important to ensure that:
\itemize{
\item the positions of input dimensions of \code{f} are consistent with those of the emulator;
\item the positions of output dimensions of \code{f} are consistent with those of the emulator, or the order of emulators placed in \code{object} if \code{object} is an
instance of the \code{bundle} class;
\item the positions of elements in the first argument of \code{aggregate} are consistent with the positions of output dimensions of the emulator, or the
order of emulators placed in \code{object} if \code{object} is an instance of the \code{bundle} class;
\item the positions of elements in the second output (if defined) of \code{f} are consistent with the positions of elements in the second argument of \code{aggregate}.
}
\item Any R vector detected in \code{x_test} and \code{y_test} will be treated as a column vector and automatically converted into a single-column
R matrix. Thus, if \code{x_test} or \code{y_test} is a single testing data point with multiple dimensions, it must be given as a matrix.
}
}
\examples{
\dontrun{

# load packages and the Python env
library(lhs)
library(dgpsi)
init_py()

# construct a 2D non-stationary function
f <- function(x) {
 sin(1/((0.7*x[1]+0.3)*(0.7*x[2]+0.3)))
 }

# generate the initial design
X <- maximinLHS(5,2)
Y <- apply(X, f, MARGIN = 1)

# generate the validation data
validate_x <- maximinLHS(30,2)
validate_y <- apply(validate_x, f, MARGIN = 1)

# training a 2-layered DGP emulator with the initial design
m <- dgp(X, Y)

# specify the ranges of the input dimensions
lim_1 <- c(0, 1)
lim_2 <- c(0, 1)
lim <- rbind(lim_1, lim_2)

# 1st wave of the sequential design with 10 steps
m <- design(m, N=10, limits = lim, f = f, x_test = validate_x, y_test = validate_y)

# 2nd wave of the sequential design with 10 steps
m <- design(m, N=10, limits = lim, f = f, x_test = validate_x, y_test = validate_y)

# 3rd wave of the sequential design with 10 steps
m <- design(m, N=10, limits = lim, f = f, x_test = validate_x, y_test = validate_y)

# draw the design created by the sequential design
draw(m,'design')

# inspect the trace of RMSEs during the sequential design
draw(m,'rmse')

# reduce the number of imputations for faster OOS
m_faster <- set_imp(m, 10)

# plot the OOS validation with the faster DGP emulator
plot(m_faster, x_test = validate_x, y_test = validate_y)
}
}
\references{
MacKay, D. J. (1992). Information-based objective functions for active data selection. \emph{Neural Computation}, \strong{4(4)}, 590-604.

Beck, J., & Guillas, S. (2016). Sequential design with mutual information for computer experiments (MICE): emulation of a tsunami model.
\emph{SIAM/ASA Journal on Uncertainty Quantification}, \strong{4(1)}, 739-766.
}
