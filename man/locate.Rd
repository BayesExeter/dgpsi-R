% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/locate.R
\name{locate}
\alias{locate}
\alias{locate.gp}
\alias{locate.dgp}
\alias{locate.bundle}
\title{Locate the next design point for a (D)GP emulator or a bundle of (D)GP emulators}
\usage{
locate(object, x_cand, n_cand, limits, method, nugget_s, verb, cores, ...)

\method{locate}{gp}(
  object,
  x_cand = NULL,
  n_cand = 200,
  limits = NULL,
  method = "ALM",
  nugget_s = 1,
  verb = TRUE,
  cores = 1,
  ...
)

\method{locate}{dgp}(
  object,
  x_cand = NULL,
  n_cand = 200,
  limits = NULL,
  method = "ALM",
  nugget_s = 1,
  verb = TRUE,
  cores = 1,
  threading = FALSE,
  aggregate = NULL,
  ...
)

\method{locate}{bundle}(
  object,
  x_cand = NULL,
  n_cand = 200,
  limits = NULL,
  method = "ALM",
  nugget_s = 1,
  verb = TRUE,
  cores = 1,
  threading = FALSE,
  aggregate = NULL,
  ...
)
}
\arguments{
\item{object}{can be one of the following:
\itemize{
\item the S3 class \code{gp}.
\item the S3 class \code{dgp}.
\item the S3 class \code{bundle}.
}}

\item{x_cand}{a matrix (with each row being a design point and column being an input dimension) that gives a candidate set
in which the next design point is determined. If \code{x_cand = NULL}, the candidate set will be generated using \code{n_cand} and
\code{limits}. Defaults to \code{NULL}.}

\item{n_cand}{an integer that gives the size of the candidate set in which the next design point is determined. This argument
is used when \code{x_cand = NULL}. Defaults to \code{200}}

\item{limits}{a two-column matrix that gives the ranges of each input dimension, or a vector of length two if there is only one
input dimension. If a vector is provided, it will be converted to a two-column row matrix. The rows of the matrix correspond
to input dimensions, and its first and second columns correspond to the minimum and maximum values of the input dimensions.
If \code{limits = NULL}, the ranges of input dimensions will be determined from the training data contained in \code{object}. This
argument is used when \code{x_cand = NULL}. Defaults to \code{NULL}.}

\item{method}{the criterion used to locate the next design point: ALM (\code{"ALM"}) or MICE (\code{"MICE"}). See references below.
Defaults to \code{"ALM"}.}

\item{nugget_s}{the value of the smoothing nugget term used when \code{method = "MICE"}. Defaults to \code{1.0}.}

\item{verb}{a bool indicating if the trace information will be printed during the function execution.
Defaults to \code{TRUE}.}

\item{cores}{the number of cores/workers to be used for the criterion calculation. If set to \code{NULL},
the number of cores is set to \verb{(max physical cores available - 1)}. Defaults to \code{1}.}

\item{...}{N/A.}

\item{threading}{a bool indicating whether to use the multi-threading to accelerate the criterion calculation.
Turning this option on could improve the speed of criterion calculations when the emulator is built with a moderately large number of
training data points and the Mat√©rn-2.5 kernel.}

\item{aggregate}{an R function with only one argument which is a vector with the length equal to:
\itemize{
\item the emulator output dimension if \code{object} is an instance of the \code{dgp} class; or
\item the number of emulators contained in \code{object} if \code{object} is an instance of the \code{bundle} class.
}

The vector represents values of the ALM or MICE criterion across different output dimensions at a design point in the candidate set. The
output of \code{aggregate} should be a single value that gives an aggregation of the ALM or MICE criterion across different output dimensions.
Set to \code{NULL} to disable the aggregation. Defaults to \code{NULL}.}
}
\value{
\itemize{
\item If \code{object} is an instance of the \code{gp} class, a list is returned:
\itemize{
\item when \code{x_cand = NULL}, the list has one slot called \code{location} that contains a vector that gives the position of determined
design point.
\item when \code{x_cand} is not \code{NULL}, the list has two slots. The first slot is called \code{index} that gives the row index of the next design point in
\code{x_cand}. The second slot is called \code{location} that gives the position of the determined design point.
}
\item If \code{object} is an instance of the \code{dgp} class, a list is returned:
\itemize{
\item when \code{x_cand = NULL} and \code{aggregate = NULL}, the list has one slot called \code{location} that contains a matrix whose rows give the positions of
determined design points with respect to different output dimensions;
\item when \code{x_cand = NULL} and \code{aggregate} is provided, the list has one slot called \code{location} that contains a single-row matrix that gives the
position of the determined design point.
\item when \code{x_cand} is not \code{NULL} and \code{aggregate = NULL}, the list has two slots:
\itemize{
\item the first slot is called \code{index} that contains a vector giving the row indices of determined design points in \code{x_cand} with respect to
different output dimensions.
\item the second slot is called \code{location} that contains a matrix whose rows give the positions of determined design points with respect to
different output dimensions.
}
\item when \code{x_cand} is not \code{NULL} and \code{aggregate} is provided, the list has two slots:
\itemize{
\item the first slot is called \code{index} that contains the row index of the next design point in \code{x_cand}.
\item the second slot is called \code{location} that contains a single-row matrix that gives the position of the determined design point.
}
}
\item If \code{object} is an instance of the \code{bundle} class, a list is returned:
\itemize{
\item when \code{x_cand = NULL} and \code{aggregate = NULL}, the list has one slot called \code{location} that contains a matrix whose rows give the positions of
determined design points with respect to different emulators in the bundle;
\item when \code{x_cand = NULL} and \code{aggregate} is provided, the list has one slot called \code{location} that contains a single-row matrix that gives the
position of the determined design point.
\item when \code{x_cand} is not \code{NULL} and \code{aggregate = NULL}, the list has two slots:
\itemize{
\item the first slot is called \code{index} that contains a vector giving the row indices of determined design points in \code{x_cand} with respect to
different emulators in the bundle.
\item the second slot is called \code{location} that contains a matrix whose rows give the positions of determined design points with respect to
different emulators in the bundle.
}
\item when \code{x_cand} is not \code{NULL} and \code{aggregate} is provided, the list has two slots:
\itemize{
\item the first slot is called \code{index} that contains the row index of the next design point in \code{x_cand}.
\item the second slot is called \code{location} that contains a single-row matrix that gives the position of the determined design point.
}
}
}
}
\description{
This function searches from a candidate set to locate the next design point to be added to a (D)GP or a bundle of
(D)GP emulators.
}
\details{
See further examples and tutorials at \url{https://mingdeyu.github.io/dgpsi-R/}.
}
\note{
\itemize{
\item The function is only applicable to GP emulators, DGP emulators without likelihood layers, or bundles of (D)GP emulators created by \code{\link[=pack]{pack()}}.
\item Any R vector detected in \code{x_cand} will be treated as a column vector and automatically converted into a single-column
R matrix.
}
}
\examples{
\dontrun{

# load packages and the Python env
library(lhs)
library(dgpsi)
init_py()

# construct a 1D non-stationary function
f <- function(x) {
 sin(30*((2*x-1)/2-0.4)^5)*cos(20*((2*x-1)/2-0.4))
}

# generate the initial design
X <- maximinLHS(10,1)
Y <- as.matrix(sapply(X, f))

# training a 2-layered DGP emulator with the global connection off
m <- dgp(X, Y, connect = F)

# specify the range of the input dimension
lim <- c(0,1)

# locate the next design point
next_point <- locate(m, limits = lim)
X_new <- next_point$location

# obtain the corresponding output at the located design point
Y_new <- f(X_new)

# combine the new input-output pair to the existing data
X <- rbind(X, X_new)
Y <- rbind(Y, Y_new)

# update the DGP emulator with the new input and output data and refit with 500 training iterations
m <- update(m, X, Y, refit = TRUE, N = 500)

# plot the LOO validation
plot(m)
}
}
\references{
MacKay, D. J. (1992). Information-based objective functions for active data selection. \emph{Neural Computation}, \strong{4(4)}, 590-604.

Beck, J., & Guillas, S. (2016). Sequential design with mutual information for computer experiments (MICE): emulation of a tsunami model.
\emph{SIAM/ASA Journal on Uncertainty Quantification}, \strong{4(1)}, 739-766.
}
